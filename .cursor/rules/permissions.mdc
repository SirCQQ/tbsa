---
description: 
globs: 
alwaysApply: true
---
# Permissions & Access Control

Guidelines for implementing granular permissions and access control throughout the application.

## **PermissionGuard Component Usage**

- **Always use PermissionGuard for conditional rendering based on permissions**
  - Wrap UI elements that require specific permissions
  - Use fallback prop for alternative content when permission is denied
  - Enable showLoading for better UX during permission checks
  - Use withRedirect only for page-level protection, not for UI elements
  - Support single or multiple permissions with AND/OR logic

```typescript
import { PermissionGuard } from "@/components/auth/permission-guard";

// ✅ DO: Single permission check
<PermissionGuard 
  permissions={["roles:create:all"]}
  fallback={<p className="text-muted-foreground">Nu ai permisiunea să creezi roluri</p>}
  showLoading={true}
>
  <Button onClick={createRole}>Creează Rol</Button>
</PermissionGuard>

// ✅ DO: Multiple permissions with OR logic (default)
<PermissionGuard 
  permissions={["buildings:read:all", "apartments:read:own"]}
  fallback={<p>Nu ai acces la această secțiune</p>}
>
  <BuildingsSection />
</PermissionGuard>

// ✅ DO: Multiple permissions with AND logic
<PermissionGuard 
  permissions={["roles:create:all", "users:update:all"]}
  requireAll={true}
  fallback={<p>Ai nevoie de ambele permisiuni</p>}
>
  <AdminPanel />
</PermissionGuard>

// ✅ DO: No permissions required (empty array allows access)
<PermissionGuard permissions={[]}>
  <PublicContent />
</PermissionGuard>

// ✅ DO: Complex admin check
<PermissionGuard 
  permissions={[
    "buildings:read:all",
    "apartments:read:all", 
    "users:read:all"
  ]}
  requireAll={true}
  withRedirect={true}
  redirectTo="/dashboard"
>
  <SuperAdminPage />
</PermissionGuard>

// ❌ DON'T: Check permissions manually in components
const hasPermission = await checkUserPermission("roles:create:all");
if (hasPermission) {
  return <Button>Creează Rol</Button>;
}
```

## **PermissionGuard Props**

- **permissions**: Required. Array of permission strings to check (empty array allows access)
- **requireAll**: Optional. Logic for multiple permissions - true = AND, false = OR (default: false)
- **children**: Required. The content to render when permission is granted
- **fallback**: Optional. Content to show when permission is denied (default: null)
- **showLoading**: Optional. Show loading spinner during auth checks (default: false)
- **requireAuth**: Optional. Require user to be authenticated (default: true)
- **withRedirect**: Optional. Redirect user when permission is denied (default: false)
- **redirectTo**: Optional. URL to redirect to when withRedirect is true (default: "/dashboard")

## **Permission Logic Examples**

```typescript
// OR Logic (requireAll = false) - User needs ANY of these permissions
<PermissionGuard 
  permissions={["water_readings:read:own", "water_readings:read:all"]}
  requireAll={false} // default
>
  <WaterReadingsChart />
</PermissionGuard>

// AND Logic (requireAll = true) - User needs ALL of these permissions
<PermissionGuard 
  permissions={["roles:create:all", "roles:update:all", "roles:delete:all"]}
  requireAll={true}
>
  <FullRoleManagement />
</PermissionGuard>

// Single permission - Array with one element
<PermissionGuard permissions={["buildings:create:all"]}>
  <CreateBuildingButton />
</PermissionGuard>

// No permissions required - Empty array
<PermissionGuard permissions={[]}>
  <PublicContent />
</PermissionGuard>
```

## **Common Permission Patterns**

```typescript
// Admin or Owner access
<PermissionGuard 
  permissions={["buildings:read:all", "apartments:read:own"]}
  fallback={<AccessDeniedMessage />}
>
  <DashboardContent />
</PermissionGuard>

// Full admin access required
<PermissionGuard 
  permissions={[
    "users:read:all",
    "roles:read:all", 
    "buildings:read:all"
  ]}
  requireAll={true}
  withRedirect={true}
>
  <AdminDashboard />
</PermissionGuard>

// Reading permissions (any scope)
<PermissionGuard 
  permissions={[
    "water_readings:read:own",
    "water_readings:read:building", 
    "water_readings:read:all"
  ]}
>
  <ReadingsDisplay />
</PermissionGuard>
```

## **When to Use withRedirect**

- **Page-level protection**: Use withRedirect for entire pages or major sections
- **Navigation protection**: Use withRedirect when user shouldn't see the page at all
- **Admin-only pages**: Use withRedirect for pages that require specific roles

```typescript
// ✅ DO: Page-level protection with redirect
export default function AdminPage() {
  return (
    <PermissionGuard 
      permission="admin_grant:create:all"
      withRedirect={true}
      redirectTo="/dashboard"
    >
      <AdminDashboard />
    </PermissionGuard>
  );
}

// ✅ DO: Major section protection with redirect
<PermissionGuard 
  permission="roles:read:all"
  withRedirect={true}
  redirectTo="/dashboard"
  fallback={<div>Redirecting...</div>}
>
  <RoleManagementPanel />
</PermissionGuard>
```

## **When NOT to Use withRedirect**

- **Small UI elements**: Buttons, links, form fields
- **Optional features**: Features that enhance UX but aren't critical
- **Conditional content**: Content that can be hidden without disrupting the page

```typescript
// ✅ DO: Hide UI elements without redirect
<div className="flex space-x-2">
  <PermissionGuard permission="roles:create:all">
    <Button onClick={createRole}>
      <Plus className="h-4 w-4 mr-2" />
      Creează Rol
    </Button>
  </PermissionGuard>
  
  <PermissionGuard permission="users:update:all">
    <Button variant="outline" onClick={assignRoles}>
      <UserCheck className="h-4 w-4 mr-2" />
      Atribuie Roluri
    </Button>
  </PermissionGuard>
</div>
```

## **Permission Hooks Usage**

- **Use usePermission hook for single permission checks**
- **Use usePermissions hook for multiple permission checks**
- **Cache results with React Query for performance**

```typescript
import { usePermission, usePermissions } from "@/components/auth/permission-guard";

// ✅ DO: Single permission check
function CreateRoleButton() {
  const { data: canCreate, isLoading } = usePermission("roles:create:all");
  
  if (isLoading) return <Skeleton />;
  if (!canCreate?.hasPermission) return null;
  
  return <Button>Creează Rol</Button>;
}

// ✅ DO: Multiple permissions check
function AdminPanel() {
  const { data: permissions } = usePermissions([
    "roles:create:all",
    "users:update:all",
    "buildings:read:all"
  ]);
  
  return (
    <div>
      {permissions?.["roles:create:all"] && <RoleManagement />}
      {permissions?.["users:update:all"] && <UserManagement />}
      {permissions?.["buildings:read:all"] && <BuildingsList />}
    </div>
  );
}
```

## **Permission Format Standards**

- **Use consistent permission format: `resource:action:scope`**
- **Resources**: buildings, apartments, users, water_readings, invite_codes, roles, admin_grant
- **Actions**: read, create, update, delete
- **Scopes**: own, all, building, null

```typescript
// ✅ DO: Use standard permission format
"buildings:read:all"     // Read all buildings
"apartments:update:own"  // Update own apartments
"users:create:all"       // Create any user
"roles:delete:all"       // Delete any role

// ❌ DON'T: Use custom or inconsistent formats
"can_read_buildings"
"building_admin"
"full_access"
```

## **Component Integration Patterns**

- **Wrap admin-only components with appropriate permissions**
- **Use fallback content for better UX**
- **Show loading states during permission checks**

```typescript
// ✅ DO: Admin dashboard sections
<PermissionGuard 
  permission="roles:read:all"
  fallback={
    <Card>
      <CardContent className="text-center py-8">
        <Shield className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
        <p>Nu ai acces la gestionarea rolurilor</p>
      </CardContent>
    </Card>
  }
  showLoading={true}
>
  <RolesManagement />
</PermissionGuard>

// ✅ DO: Action buttons with permissions
<div className="flex space-x-2">
  <PermissionGuard permission="roles:create:all">
    <Button onClick={createRole}>
      <Plus className="h-4 w-4 mr-2" />
      Creează Rol
    </Button>
  </PermissionGuard>
  
  <PermissionGuard permission="users:update:all">
    <Button variant="outline" onClick={assignRoles}>
      <UserCheck className="h-4 w-4 mr-2" />
      Atribuie Roluri
    </Button>
  </PermissionGuard>
</div>
```

## **Navigation & Menu Integration**

- **Hide navigation items based on permissions**
- **Use PermissionGuard for sidebar links**
- **Provide fallback navigation for restricted users**

```typescript
// ✅ DO: Conditional navigation
<nav>
  <PermissionGuard permission="buildings:read:all">
    <NavLink href="/dashboard/admin/buildings">Clădiri</NavLink>
  </PermissionGuard>
  
  <PermissionGuard permission="roles:read:all">
    <NavLink href="/dashboard/admin/permissions">Permisiuni</NavLink>
  </PermissionGuard>
  
  <PermissionGuard permission="users:read:all">
    <NavLink href="/dashboard/admin/users">Utilizatori</NavLink>
  </PermissionGuard>
</nav>
```

## **Error Handling & Fallbacks**

- **Always provide meaningful fallback content**
- **Use consistent error messages**
- **Handle loading states gracefully**

```typescript
// ✅ DO: Meaningful fallbacks
<PermissionGuard 
  permission="admin_grant:create:all"
  fallback={
    <Alert>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>Acces Restricționat</AlertTitle>
      <AlertDescription>
        Doar SUPER_ADMIN poate atribui roluri administrative.
      </AlertDescription>
    </Alert>
  }
>
  <AdminGrantForm />
</PermissionGuard>

// ✅ DO: Loading states
<PermissionGuard 
  permission="roles:create:all"
  showLoading={true}
  fallback={<EmptyState message="Nu poți crea roluri" />}
>
  <CreateRoleModal />
</PermissionGuard>
```

## **Performance Considerations**

- **Permissions are cached for 5 minutes by default**
- **Use React Query's staleTime for optimal caching**
- **Avoid unnecessary permission checks in render loops**

```typescript
// ✅ DO: Cache permissions efficiently
const { data: permissions } = usePermissions([
  "roles:create:all",
  "roles:update:all",
  "roles:delete:all"
]);

// ✅ DO: Use memo for expensive permission checks
const AdminActions = memo(() => (
  <PermissionGuard permission="admin_grant:create:all">
    <ExpensiveAdminComponent />
  </PermissionGuard>
));

// ❌ DON'T: Check permissions in loops
{items.map(item => (
  <PermissionGuard key={item.id} permission="items:update:all">
    <ItemComponent item={item} />
  </PermissionGuard>
))}
```

## **Testing Permissions**

- **Mock permission responses in tests**
- **Test both granted and denied permission states**
- **Verify fallback content renders correctly**

```typescript
// ✅ DO: Test permission states
describe("PermissionGuard", () => {
  it("renders children when permission is granted", () => {
    mockPermissionCheck.mockResolvedValue({ hasPermission: true });
    render(
      <PermissionGuard permission="roles:create:all">
        <Button>Create Role</Button>
      </PermissionGuard>
    );
    expect(screen.getByText("Create Role")).toBeInTheDocument();
  });

  it("renders fallback when permission is denied", () => {
    mockPermissionCheck.mockResolvedValue({ hasPermission: false });
    render(
      <PermissionGuard 
        permission="roles:create:all"
        fallback={<p>Access Denied</p>}
      >
        <Button>Create Role</Button>
      </PermissionGuard>
    );
    expect(screen.getByText("Access Denied")).toBeInTheDocument();
  });
});
```

## **Best Practices**

- **Always wrap admin functionality with PermissionGuard**
- **Use descriptive fallback messages**
- **Enable loading states for better UX**
- **Group related permissions using usePermissions hook**
- **Cache permission results to avoid unnecessary API calls**
- **Test permission boundaries thoroughly**
- **Use consistent permission naming conventions**
- **Document required permissions for each component**
