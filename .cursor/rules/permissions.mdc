---
description: 
globs: 
alwaysApply: true
---
# Permissions & Access Control

Guidelines for implementing granular permissions and access control throughout the application.

## **PermissionGuard Component Usage**

- **Always use PermissionGuard for conditional rendering based on permissions**
  - Wrap UI elements that require specific permissions
  - Use fallback prop for alternative content when permission is denied
  - Enable showLoading for better UX during permission checks

```typescript
import { PermissionGuard } from "@/components/auth/permission-guard";

// ✅ DO: Wrap buttons/actions with permission checks
<PermissionGuard 
  permission="roles:create:all"
  fallback={<p className="text-muted-foreground">Nu ai permisiunea să creezi roluri</p>}
  showLoading={true}
>
  <Button onClick={createRole}>Creează Rol</Button>
</PermissionGuard>

// ✅ DO: Use for entire sections
<PermissionGuard permission="users:read:all">
  <UsersManagementSection />
</PermissionGuard>

// ❌ DON'T: Check permissions manually in components
const hasPermission = await checkUserPermission("roles:create:all");
if (hasPermission) {
  return <Button>Creează Rol</Button>;
}
```

## **Permission Hooks Usage**

- **Use usePermission hook for single permission checks**
- **Use usePermissions hook for multiple permission checks**
- **Cache results with React Query for performance**

```typescript
import { usePermission, usePermissions } from "@/components/auth/permission-guard";

// ✅ DO: Single permission check
function CreateRoleButton() {
  const { data: canCreate, isLoading } = usePermission("roles:create:all");
  
  if (isLoading) return <Skeleton />;
  if (!canCreate?.hasPermission) return null;
  
  return <Button>Creează Rol</Button>;
}

// ✅ DO: Multiple permissions check
function AdminPanel() {
  const { data: permissions } = usePermissions([
    "roles:create:all",
    "users:update:all",
    "buildings:read:all"
  ]);
  
  return (
    <div>
      {permissions?.["roles:create:all"] && <RoleManagement />}
      {permissions?.["users:update:all"] && <UserManagement />}
      {permissions?.["buildings:read:all"] && <BuildingsList />}
    </div>
  );
}
```

## **Permission Format Standards**

- **Use consistent permission format: `resource:action:scope`**
- **Resources**: buildings, apartments, users, water_readings, invite_codes, roles, admin_grant
- **Actions**: read, create, update, delete
- **Scopes**: own, all, building, null

```typescript
// ✅ DO: Use standard permission format
"buildings:read:all"     // Read all buildings
"apartments:update:own"  // Update own apartments
"users:create:all"       // Create any user
"roles:delete:all"       // Delete any role

// ❌ DON'T: Use custom or inconsistent formats
"can_read_buildings"
"building_admin"
"full_access"
```

## **Component Integration Patterns**

- **Wrap admin-only components with appropriate permissions**
- **Use fallback content for better UX**
- **Show loading states during permission checks**

```typescript
// ✅ DO: Admin dashboard sections
<PermissionGuard 
  permission="roles:read:all"
  fallback={
    <Card>
      <CardContent className="text-center py-8">
        <Shield className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
        <p>Nu ai acces la gestionarea rolurilor</p>
      </CardContent>
    </Card>
  }
  showLoading={true}
>
  <RolesManagement />
</PermissionGuard>

// ✅ DO: Action buttons with permissions
<div className="flex space-x-2">
  <PermissionGuard permission="roles:create:all">
    <Button onClick={createRole}>
      <Plus className="h-4 w-4 mr-2" />
      Creează Rol
    </Button>
  </PermissionGuard>
  
  <PermissionGuard permission="users:update:all">
    <Button variant="outline" onClick={assignRoles}>
      <UserCheck className="h-4 w-4 mr-2" />
      Atribuie Roluri
    </Button>
  </PermissionGuard>
</div>
```

## **Navigation & Menu Integration**

- **Hide navigation items based on permissions**
- **Use PermissionGuard for sidebar links**
- **Provide fallback navigation for restricted users**

```typescript
// ✅ DO: Conditional navigation
<nav>
  <PermissionGuard permission="buildings:read:all">
    <NavLink href="/dashboard/admin/buildings">Clădiri</NavLink>
  </PermissionGuard>
  
  <PermissionGuard permission="roles:read:all">
    <NavLink href="/dashboard/admin/permissions">Permisiuni</NavLink>
  </PermissionGuard>
  
  <PermissionGuard permission="users:read:all">
    <NavLink href="/dashboard/admin/users">Utilizatori</NavLink>
  </PermissionGuard>
</nav>
```

## **Error Handling & Fallbacks**

- **Always provide meaningful fallback content**
- **Use consistent error messages**
- **Handle loading states gracefully**

```typescript
// ✅ DO: Meaningful fallbacks
<PermissionGuard 
  permission="admin_grant:create:all"
  fallback={
    <Alert>
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>Acces Restricționat</AlertTitle>
      <AlertDescription>
        Doar SUPER_ADMIN poate atribui roluri administrative.
      </AlertDescription>
    </Alert>
  }
>
  <AdminGrantForm />
</PermissionGuard>

// ✅ DO: Loading states
<PermissionGuard 
  permission="roles:create:all"
  showLoading={true}
  fallback={<EmptyState message="Nu poți crea roluri" />}
>
  <CreateRoleModal />
</PermissionGuard>
```

## **Performance Considerations**

- **Permissions are cached for 5 minutes by default**
- **Use React Query's staleTime for optimal caching**
- **Avoid unnecessary permission checks in render loops**

```typescript
// ✅ DO: Cache permissions efficiently
const { data: permissions } = usePermissions([
  "roles:create:all",
  "roles:update:all",
  "roles:delete:all"
]);

// ✅ DO: Use memo for expensive permission checks
const AdminActions = memo(() => (
  <PermissionGuard permission="admin_grant:create:all">
    <ExpensiveAdminComponent />
  </PermissionGuard>
));

// ❌ DON'T: Check permissions in loops
{items.map(item => (
  <PermissionGuard key={item.id} permission="items:update:all">
    <ItemComponent item={item} />
  </PermissionGuard>
))}
```

## **Testing Permissions**

- **Mock permission responses in tests**
- **Test both granted and denied permission states**
- **Verify fallback content renders correctly**

```typescript
// ✅ DO: Test permission states
describe("PermissionGuard", () => {
  it("renders children when permission is granted", () => {
    mockPermissionCheck.mockResolvedValue({ hasPermission: true });
    render(
      <PermissionGuard permission="roles:create:all">
        <Button>Create Role</Button>
      </PermissionGuard>
    );
    expect(screen.getByText("Create Role")).toBeInTheDocument();
  });

  it("renders fallback when permission is denied", () => {
    mockPermissionCheck.mockResolvedValue({ hasPermission: false });
    render(
      <PermissionGuard 
        permission="roles:create:all"
        fallback={<p>Access Denied</p>}
      >
        <Button>Create Role</Button>
      </PermissionGuard>
    );
    expect(screen.getByText("Access Denied")).toBeInTheDocument();
  });
});
```

## **Best Practices**

- **Always wrap admin functionality with PermissionGuard**
- **Use descriptive fallback messages**
- **Enable loading states for better UX**
- **Group related permissions using usePermissions hook**
- **Cache permission results to avoid unnecessary API calls**
- **Test permission boundaries thoroughly**
- **Use consistent permission naming conventions**
- **Document required permissions for each component**
